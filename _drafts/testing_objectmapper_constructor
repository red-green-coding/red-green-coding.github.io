---
layout: post
title:  "Avoid mocking that ObjectMapper! (part 2)"
categories: bettertests
---

## Test code should be decoupled from the code it tests

Lets assume now we have a new requirement. Our task is to replace Jackson with an alternative implementation Gson. We first make the change to our code

{% highlight java %}
public class MyService3 {
    private Gson mapper;
    private MyOtherService myOtherService;

    MyService3(Gson mapper, MyOtherService myOtherService) {
        this.mapper = mapper;
        this.myOtherService = myOtherService;
    }

    void useData(String json) {
        try {
            var dto = mapper.fromJson(json, MyDto.class);
            myOtherService.useDto(dto);
        } catch (JsonSyntaxException e) {
            throw new RuntimeException(e);
        }
    }
}
{% endhighlight %}

When we re-run our tests we see that they are failing

{% highlight bash %}
sample.MyService3Test

    âœ˜ canConsumeJson()

      NullPointerException: Cannot invoke "com.google.gson.Gson.fromJson(String, java.lang.Class)"
        because "this.mapper"
{% endhighlight %}

The reason is that our test now didn't construct the code under test correctly. Of course we could fix that by modifiying the test but still this is
an unfortunate situation. A test should ideally only focus on the behaviour of the code under test and not make too many assumptions about its internals.
By the design choice to make

It shouldn't really matter what kind of mapper we are using inside of _MyService_. What should matter is if it behaves correctly. The problem
here is that the code
